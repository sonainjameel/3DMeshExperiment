 'Model 3': '409624.stl',
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Scene 01 - ICIP Study</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background:#111; }
    canvas { width: 100%; height: 100%; display:block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.update();

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 2);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048,2048);
    dirLight.shadow.camera.left=-10;
    dirLight.shadow.camera.right=10;
    dirLight.shadow.camera.top=10;
    dirLight.shadow.camera.bottom=-10;
    dirLight.shadow.camera.near=1;
    dirLight.shadow.camera.far=30;
    scene.add(dirLight);

    // Load STL mesh
    const stlLoader = new STLLoader();
    const stlFiles = [
      { name: '98479.stl', x:0, y:0, z:0, scale:0.03 }
    ];

    const metrics = {}; // store hidden metrics for main.html

    stlFiles.forEach(file=>{
      stlLoader.load(file.name, geometry=>{
        geometry.computeVertexNormals();

        const material = new THREE.MeshPhysicalMaterial({
          color:0xcccccc, roughness:0.6, metalness:0,
          clearcoat:0.05, clearcoatRoughness:0.8, transmission:0.2, thickness:0.5
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.position.set(file.x,file.y,file.z);
        mesh.scale.set(file.scale,file.scale,file.scale);
        mesh.rotateX(-Math.PI/2);
        scene.add(mesh);

        // Geometry metric
        const vertices = geometry.attributes.position.count;
        const bbox = new THREE.Box3().setFromBufferAttribute(geometry.attributes.position);
        const volume = bbox.getSize(new THREE.Vector3()).x * bbox.getSize(new THREE.Vector3()).y * bbox.getSize(new THREE.Vector3()).z;
        const geomDetail = vertices / volume;

        metrics[file.name] = {
          vertices, geomDetail, bboxVolume: volume
        };
      });
    });

    // Ground
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(2,64),
      new THREE.MeshPhysicalMaterial({color:0x888888})
    );
    ground.rotation.x=-Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const clock = new THREE.Clock();

    function animateLight(){
      const t = clock.getElapsedTime();

      // Move light
      const radius = 5 + Math.sin(t*0.4)*2;
      dirLight.position.set(
        Math.sin(t*0.9)*radius,
        6 + Math.sin(t*1.5)*3,
        Math.cos(t*0.9)*radius
      );

      // Color sweep
      const baseHue = (t*0.08)%1;
      const flashHue = Math.random()<0.03?Math.random():baseHue;
      dirLight.color.setHSL(flashHue,1,0.55);

      // Intensity flash
      let intensity = 1.2 + Math.sin(t*1.2)*0.9;
      intensity += Math.sin(t*(2 + Math.sin(t*0.5)*3))*0.7;
      if(Math.random()<0.02) intensity += 4+Math.random()*4;
      intensity += (Math.random()-0.5)*0.5;
      dirLight.intensity = Math.max(0.3,intensity);
    }

    function render(){
      requestAnimationFrame(render);
      animateLight();
      renderer.render(scene,camera);
    }
    render();

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Function for main.html to get metrics
    window.getSceneMetrics = () => {
      return metrics; // send as object
    };
  </script>
</body>
</html>
 
